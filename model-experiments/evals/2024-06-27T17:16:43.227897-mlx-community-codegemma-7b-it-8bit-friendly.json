[["<bos><start_of_turn>user\nYou are a code debugging assistant for apps that use Hono (web framework), \nNeon (serverless postgres), Drizzle (ORM), and run on Cloudflare workers.\nYou need to help craft a request to route handlers. \nYou will be provided the source code for handlers, and you should generate\nquery parameters and a request body that will test the request.\n\nBe clever and creative with test data. Avoid just writing things like \"test\".\n\nFor example, if you get a route like `/users/:id`, you should return a URL like:\n`/users/1234567890` and a routeParams parameter like this:\n\n{ \"routeParams\": { \"key\": \":id\", \"value\": \"1234567890\" } }\n<end_of_turn>\n<start_of_turn>user\nI need to make a request to one of my Hono api handlers.\n\nHere are some recent requests/responses, which you can use as inspiration for future requests.\n\n<history>\nNo history\n</history>\n\nThe request you make should be a GET request to route: /api/geese/:id\n\nHere is the code for the handler:\n`\nasync (c) => {\n  const sql = neon(c.env.DATABASE_URL)\n  const db = drizzle(sql);\n\n  const id = c.req.param('id');\n\n  const goose = (await db.select().from(geese).where(eq(geese.id, +id)))?.[0];\n\n  if (!goose) {\n    return c.json({ message: 'Goose not found' }, 404);\n  }\n\n  return c.json(goose);\n}\n`\n<end_of_turn>\n<start_of_turn>model\n", "## Test Data for /api/geese/:id Handler\n\n**Request:**\n\n**Method:** GET\n\n**URL:** `/api/geese/1234567890`\n\n**Route Params:**\n\n```json\n{\n  \"routeParams\": {\n    \"key\": \":id\",\n    \"value\": \"1234567890\"\n  }\n}\n```\n\n**Response:**\n\n```json\n{\n  \"id\": 1234567890,\n  \"name\": \"Donald\",\n  \"species\": \"Mallard\",\n  \"color\": \"White\",\n  \"location\": \"Central Park\",\n  \"age\": 5\n}\n```\n\n**Note:** This is just an example. The actual data returned by the handler will vary depending on the data in your database.\n\n**Additional Test Data:**\n\n* Test with a non-existent goose ID:\n\n**Request:**\n\n**Method:** GET\n\n**URL:** `/api/geese/9999999999`\n\n**Route Params:**\n\n```json\n{\n  \"routeParams\": {\n    \"key\": \":id\",\n    \"value\": \"9999999999\"\n  }\n}\n```\n\n**Response:**\n\n```json\n{\n  \"message\": \"Goose not found\"\n}\n```\n\n* Test with a non-numeric ID:\n\n**Request:**\n\n**Method:** GET\n\n**URL:** `/api/geese/abc`\n\n**Route Params:**\n\n```json\n{\n  \"routeParams\": {\n    \"key\": \":id\",\n    \"value\": \"abc\"\n  }\n}\n```\n\n**Response:**\n\n```json\n{\n  \"message\": \"Invalid goose ID\"\n}\n```\n\n* Test with a missing ID:\n\n**Request:**\n\n**Method:** GET\n\n**URL:** `/api/geese/`\n\n**Route Params:**\n\n```json\n{\n  \"routeParams\": {\n    \"key\": \":id\",\n    \"value\": \"\"\n  }\n}\n```\n\n**Response:**\n\n```json\n{\n  \"message\": \"Missing goose ID\"\n}\n```"], ["<bos><start_of_turn>user\nYou are a code debugging assistant for apps that use Hono (web framework), \nNeon (serverless postgres), Drizzle (ORM), and run on Cloudflare workers.\nYou need to help craft a request to route handlers. \nYou will be provided the source code for handlers, and you should generate\nquery parameters and a request body that will test the request.\n\nBe clever and creative with test data. Avoid just writing things like \"test\".\n\nFor example, if you get a route like `/users/:id`, you should return a URL like:\n`/users/1234567890` and a routeParams parameter like this:\n\n{ \"routeParams\": { \"key\": \":id\", \"value\": \"1234567890\" } }\n<end_of_turn>\n<start_of_turn>user\nI need to make a request to one of my Hono api handlers.\n\nHere are some recent requests/responses, which you can use as inspiration for future requests.\n\n<history>\nNo history\n</history>\n\nThe request you make should be a PATCH request to route: /api/geese/:id\n\nHere is the code for the handler:\n`\nasync (c) => {\n  const sql = neon(c.env.DATABASE_URL)\n  const db = drizzle(sql);\n\n  const id = c.req.param('id');\n  const { name } = await c.req.json()\n\n  const goose = (await db.update(geese).set({ name }).where(eq(geese.id, +id)).returning())?.[0];\n\n  if (!goose) {\n    return c.json({ message: 'Goose not found' }, 404);\n  }\n\n  return c.json(goose);\n}\n`\n<end_of_turn>\n<start_of_turn>model\n", "## Test Data for /api/geese/:id PATCH Request\n\n**URL:**\n\n`/api/geese/1234567890`\n\n**Request Body:**\n\n```json\n{\n  \"name\": \"Fluffy the Goose\"\n}\n```\n\n**Route Params:**\n\n```json\n{\n  \"routeParams\": {\n    \"key\": \":id\",\n    \"value\": \"1234567890\"\n  }\n}\n```\n\n**Explanation:**\n\n* The URL path includes the specific goose ID `1234567890`, matching the route parameter \":id\".\n* The request body contains a JSON object with a new name for the goose, \"Fluffy the Goose\".\n* The routeParams object provides a key-value pair for the \":id\" parameter and its value.\n\n**Additional Test Data:**\n\n* Test with a non-existent goose ID, e.g., `/api/geese/9999999999`. This should return a 404 Not Found response.\n* Test with an invalid request body, e.g., missing the \"name\" field. This should return a 400 Bad Request response.\n* Test with a request body containing an empty string for the \"name\" field. This should be allowed and update the goose name to an empty string.\n* Test with a request body containing a special character in the \"name\" field. This should be allowed and update the goose name accordingly.\n\n**Note:** These are just a few examples. You can add more test cases to cover different scenarios and edge cases."]]